<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel = "Shortcut Icon" href= '/favicon.ico' >
    <title>芋仔的个人博客</title>
    <link rel="stylesheet"
      href="/css/atom-one-dark.min.css">
    
<link rel="stylesheet" href="/css/bootstrap.min.css">

    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/fontdiao.css">

    
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 6.3.0"></head>
<body class=" post-page">
    <div class="main">
        <header id = 'daohang'>
  <nav class="navbar navbar-default navbar-fixed-top" role="navigation" >
<div class="container-fluid">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" style="cursor: pointer"><i class= 'icon-home' id = 'slide_aboutme' ></i> 芋仔</a>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="nav navbar-nav navbar-right">
      
          <li><a href="/" >Welcome</a></li>
      
          <li><a href="/archives" >Archives</a></li>
      
          <li><a href="/my-works" >My-Work</a></li>
      
    </ul>
  </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>

</header>

<div class="inner-page-shell">
    <article>
      <div class="container inner-content-container">
      <div class="row inner-content-row">
        <div class="col-xs-12 col-sm-8 col-md-8 col-lg-8 category_col">
          <div class="well post-shell">
        <h2 class="post-title">
            <span>可视化埋点（四）：如何维持 Xpath 稳定性</span>
        </h2>
        <section class="post-content">
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在之前的文章中提到一些 xpath 实战的边界场景，评论区小伙伴比较感兴趣，故写此篇文章进行记录。本文主要将 xpath 的稳定性分为三个环节（是足够涵盖之前文章提出的一些边界场景的）：</p>
<ol>
<li>xpath 生成的边界场景：div[1] 与 div，svg 元素，id 的识别</li>
<li>实际业务中，dom 结构不稳定的场景分析：逻辑与表达式，三元表达式，动态弹窗，动态组件</li>
<li>xpath 的特殊场景：列表标记。</li>
</ol>
<span id="more"></span>

<h2 id="xpath-简介"><a href="#xpath-简介" class="headerlink" title="xpath 简介"></a>xpath 简介</h2><p>在正文开始前，还是先对 xpath 进行一个简单的介绍，毕竟即便是工作几年的前端，我想不是特别注意的话，多半是没有听说过 xpath。</p>
<p>xpath 历史渊源什么的，不在此处梳理，在我们现代的 web 开发体系下，用简单的一句话来讲，就是指 元素 在 整个文档流中 当下  所处的位置。</p>
<p>举个例子，html 中有如下 dom 结构：</p>
<pre><code class="html">&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;li&gt;3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;p&gt;一个p&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在上述的 结构下，可以用一个字符串标识 内容为 3，tag 为 li 的元素：<code>/html/body/div[1]/ul/li[3]</code>。这一字符串可以通过 chrome 下选中元素，右键复制 -&gt; 复制完整 xpath(此处完整 xpath 和 xpath 的区别，笔者本身也没有做过更仔细的研究，一个非常明显的区别就在于完整 xpath 不会对路径中有 id 属性的元素做处理)。不过这一生成方法浏览器并没有暴露出来，需要使用者自行实现。</p>
<p>一个非常简易的获取元素 xpath 的代码如下：</p>
<pre><code class="js">function getXpath(ele) &#123;
    let cur = ele;
    const path = [];
    while (cur.nodeType === Node.ELEMENT_NODE) &#123;
        const currentTag = cur.nodeName.toLowerCase();
        const nth = findIndex(cur, currentTag);
        path.push(`$&#123;(cur.tagName).toLowerCase()&#125;$&#123;(nth === 1 ? &#39;&#39; : `[$&#123;nth&#125;]`)&#125;`);
        cur = cur.parentNode;
    &#125;
    return `/$&#123;path.reverse().join(&#39;/&#39;)&#125;`;
&#125;

// 其中 findIndex 代码如下：
function findIndex(ele, currentTag) &#123;
    let nth = 0;
    while (ele) &#123;
        if (ele.nodeName.toLowerCase() === currentTag) nth += 1;
        ele = ele.previousElementSibling;
    &#125;
    return nth;
&#125;
</code></pre>
<p>拿到 xpath 之后，想要通过 xpath 反查元素，可以通过浏览器原生的方法，完整的使用介绍见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/XPath/Introduction_to_using_XPath_in_JavaScript">这篇文章</a>。</p>
<p>简单来讲，用如下代码即可通过 xpath 反查到元素：</p>
<pre><code class="js">function getEleByXpath(xpath) &#123;
    const doc = document;
    const result = doc.evaluate(xpath, doc);
    const item = result.iterateNext();
    return item;
&#125;
</code></pre>
<h2 id="生成-xpath-的边界场景"><a href="#生成-xpath-的边界场景" class="headerlink" title="生成 xpath 的边界场景"></a>生成 xpath 的边界场景</h2><p>简单介绍 xpath 之后，便是本文要讨论的主题，首先是 xpath 的一些边界场景，本章将会从 div[1]、svg 元素 以及 id 的处理来分析实战中的经验及改进方法。</p>
<h3 id="div-1-与-div"><a href="#div-1-与-div" class="headerlink" title="div[1] 与 div"></a>div[1] 与 div</h3><p>在上文的例子中，可以看到对于 <code>/html/body/div[1]/ul/li[3]</code> 中的 ul 元素，浏览器直接生成的 ul 元素，并没有 ul[1]，而是直接 ul，这在当前的 dom 结构下，确实并不影响，但是在实际场景中，如果由于用户的操作，导致当下的 dom 结构变化成如下情形：</p>
<pre><code class="html">&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;!--原本的 li 3 消失--&gt;
                &lt;!--&lt;li&gt;3&lt;/li&gt;--&gt;
            &lt;/ul&gt;
            &lt;!--新增了 ul，并且也有 3个 li 元素--&gt;
            &lt;ul&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;li&gt;3&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;p&gt;一个p&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>此时，执行 <code>getEleByXpath(&#39;/html/body/div[1]/ul/li[3]&#39;)</code>，由于 ul 没有指明位置，当第一个 ul 下不存在 li[3] 的时候，浏览器会尝试寻找 ul[2]&#x2F;li[3]，此时命中，便会将原本第一个 ul&#x2F;li[3] 判定成 第二个 ul&#x2F;li[3]。</p>
<p>这在可视化埋点场景下，就是用户在录入埋点的时候，由于 dom 结构中仅有一个 ul&#x2F;li[3]，录入了该 xpath，但是在实际场景中由于用户的交互，导致原本的 ul&#x2F;li[3] 消失，新增了 ul[2]&#x2F;li[3]。而浏览器的判断，对于 没有指明 ul[x] 中 x 的情况，会向下继续寻找符合条件的元素，此时就会发生误判。</p>
<p>故在实际使用时，生成的 xpath，必须显式的指明，当前元素在 dom 结构中，同类型元素的第几个，而非之前代码中，如果是位于第一个便省略的处理。</p>
<p>修改后的 getXpath 如下：</p>
<pre><code class="js">function getXpath(ele) &#123;
    let cur = ele;
    const path = [];
    while (cur.nodeType === Node.ELEMENT_NODE) &#123;
        const currentTag = cur.nodeName.toLowerCase();
        const nth = findIndex(cur, currentTag);
        // 此处不再判断是否是第一个元素，全部追加 nth
        path.push(`$&#123;(cur.tagName).toLowerCase()&#125;[$&#123;nth&#125;]`);
        cur = cur.parentNode;
    &#125;
    return `/$&#123;path.reverse().join(&#39;/&#39;)&#125;`;
&#125;

// 其中 findIndex 代码如下：
// 省略 findIndex 的代码
</code></pre>
<p>通过显式指明 不同 tag 类型位于当前同类型的第几个，可以有效避免省略 [1] 带来的误判，此为 xpath 中的第一个踩坑点。</p>
<h3 id="svg-元素"><a href="#svg-元素" class="headerlink" title="svg 元素"></a>svg 元素</h3><p>对于 svg 元素，假设有如下 dom 结构。</p>
<pre><code class="html">&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;My first SVG&lt;/h1&gt;
        &lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;
            &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;green&quot; stroke-width=&quot;4&quot; fill=&quot;yellow&quot; /&gt;
        &lt;/svg&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>通过上文的 getXpath 方法，获取 circle 元素，可以得到如下 xpath：<code>/html[1]/body[1]/svg[1]/circle[1]</code>。</p>
<p>此时通过上文介绍的 <code>getEleByXpath(&#39;/html[1]/body[1]/svg[1]/circle[1]&#39;)</code>，会发现的到的是空值，这是因为浏览器不支持 svg 元素的查找。</p>
<p>该方法对于 svg 元素，仅支持如下形式的查找：<code>html[1]/body[1]/*[name()=&#39;svg&#39;][1]/*[name()=&#39;circle&#39;][1]</code>。</p>
<p>故，对于 svg 标签，想要浏览器能够查找到，只需要将 svg 替换为 <code>*[name()=&#39;svg&#39;]</code> 即可。修改 xpath 获取代码如下：</p>
<pre><code class="js">const svgTags = [&#39;svg&#39;, &#39;path&#39;, &#39;g&#39;, &#39;image&#39;, &#39;text&#39;, &#39;line&#39;, &#39;rect&#39;, &#39;polygon&#39;, &#39;circle&#39;, &#39;ellipse&#39;];

function getTagName(ele) &#123;
    const tag = ele.tagName.toLowerCase();
    if (svgTags.indexOf(tag) !== -1) &#123;
        // 如果是 svg 元素，替换为 name()=&#39;xxx&#39; 的形式
        return `*[name()=&#39;$&#123;tag&#125;&#39;]`;
    &#125;
    return tag;
&#125;;

function getXpath(ele) &#123;
    let cur = ele;
    const path = [];
    while (cur.nodeType === Node.ELEMENT_NODE) &#123;
        const currentTag = cur.nodeName.toLowerCase();
        const nth = findIndex(cur, currentTag);
        // 替换为 gettagName(cur) 获取元素的 tag
        path.push(`$&#123;(getTagName(cur))&#125;[$&#123;nth&#125;]`);
        cur = cur.parentNode;
    &#125;
    return `/$&#123;path.reverse().join(&#39;/&#39;)&#125;`;
&#125;
</code></pre>
<p>通过这样的方法，就可以实现对 svg 元素的识别。虽说如今回过头来看，改动其实很细微，但是在实际的落地过程中，这些问题都是当作 bug 来处理，而且彼时还要兼容旧版本的 xpath，实际的痛是真的痛。</p>
<h3 id="id-的识别"><a href="#id-的识别" class="headerlink" title="id 的识别"></a>id 的识别</h3><p>在浏览器自动生成的完整 xpath 中，对带有 id 的元素不会做特殊的处理，但是如果选择的是复制 xpath，会对有 id 属性标识的元素有特殊的处理。试想如下 dom 结构：</p>
<pre><code class="html">&lt;html&gt;
    &lt;body id=&quot;body&quot;&gt;
        &lt;h1 id=&quot;h1&quot;&gt;My first SVG&lt;/h1&gt;
        &lt;div id=&quot;h1&quot;&gt;div h1&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>此时选中 h1 并复制其 xpath 和完整 xpath，可以得到如下两个 xpath:</p>
<p><code>//*[@id=&quot;h1&quot;]</code> 和 <code>/html/body/h1</code> (可以看出来，浏览器获取的 h1 是没有带序号的，这个问题已经在上文讨论过，故此处不再赘述)。</p>
<p>在这里，可以看到 xpath 的一个新的写法， <code>/*[@id=&quot;xxx&quot;]</code>，由于 id 在 html 中，确实是一个比较特殊的存在，虽然在现代 web 开发中，id 越来越不常用，但是也阻止不了大家对同一个 id 只有一个的共识。</p>
<p>那么对于可视化埋点，如果加入 id 的判定，是否能够让 xpath 更加稳定，或者说减少误判呢？</p>
<p>我的理解是能，对于业务中，比较常见的 tab 场景，就可以在每一个 tab 中加入 id，如果在 xpath 中能够对 id 进行处理，那么这几个 tab 即便再相似，也不会出现误判的情形，关于 tab 场景，会在后文讨论，此处仅仅讨论 xpath 如何支持 id。</p>
<p>首先，浏览器默认生成的，基本上都是 <code>/*[@id=&quot;xxx&quot;]</code>，此处由于 id 基本只有唯一一个，所以省略了 tag 的标识，但是实际场景中， id 的唯一性保证其实是由使用者保证的，并不可靠，故我在此处加入了 tag 的标识，对于上述结构中的 h1，我选择用 <code>/h1[@id=&quot;h1&quot;]</code> 进行替换。而经验证，浏览器的 getEleByXpath 是能够识别带 tag 的场景。</p>
<p>同时，考虑到 id 有了之后，其实再往上的 dom 结构显得并不重要，故对于在 路径中遇到了包含 id 属性的 dom 节点，将不会再向上搜集结构，对于上文中的 h1, 他的完整 xpath 将会是 <code>//h1[@id=&quot;h1&quot;]</code>。用 &#x2F; 替代了上层的 dom 结构。</p>
<p>同时，我们一般业务中使用的 svg，多半都是从某些软件中直接导出的，这些软件的导出，会默认存在一些 id，同时由于 svg 元素在曝光点 intersectionObserver api 中并不生效，故对于包含了 svg 的 xpath，遇到了包含 id 属性的 dom 节点，不会停止向上搜集，同时在实际记录曝光的时候，会根据 xpath 选择最近的非 svg 元素的 dom 节点作为曝光的依据。</p>
<p>至此，对于 id 的处理，意义主要在于提升埋点的准确性，需要做的改造有：</p>
<ol>
<li><p>对于不是 svg 元素的场景，遇到了有 id 属性的 dom 节点，停止向上搜查，用 <code>/</code> 替代上层的 dom，并在 id 中保留该节点 tag 以便增强稳定性</p>
</li>
<li><p>对于有 svg 元素的场景，保留所有的 dom 层级，对于遇到 id 属性的场景，保留 <code>/tag[@id=&quot;xxx&quot;]</code> 的形式。</p>
</li>
</ol>
<p>改写后的完整代码如下：</p>
<pre><code class="js">export function getXpath(ele: HTMLElement) &#123;
    if (!isDOM(ele)) &#123;
        return null;
    &#125;
    let cur: HTMLElement | null = ele;
    // 是否追加过 id 
    let hasAddedId = false;
    // 判断当前节点是否是 svg 元素
    // 默认认为一般不会有人在 svg 中嵌套 普通 dom 节点
    const hasSvgEle = svgTags.indexOf(cur.tagName.toLowerCase()) !== -1;

    const path = [];
    while (cur &amp;&amp; cur.nodeType === Node.ELEMENT_NODE) &#123;
        const currentTag = cur.nodeName.toLowerCase();
        // 查找位置
        const nth = findIndex(cur, currentTag);
        let idMark = &#39;&#39;;
        if (!hasAddedId &amp;&amp; cur.hasAttribute(&#39;id&#39;)) &#123;
            // 仅保留最近一层的id
            idMark = `[@id=&quot;$&#123;cur.id&#125;&quot;]`;
            // 标记加过 id 了
            hasAddedId = true;
        &#125;
        let nthmark = &#39;&#39;;
        if (idMark) &#123;
            // 有了 id ，可以忽略位置
            nthmark = &#39;&#39;;
            // ignoreTags = [&#39;html&#39;, &#39;body&#39;]
        &#125; else if (ignoreTags.indexOf(currentTag) === -1) &#123;
            nthmark = `[$&#123;nth&#125;]`;
        &#125; else &#123;
            // 对于body, html 忽略 nth
            nthmark = &#39;&#39;;
        &#125;
        path.push(`$&#123;getTagName(cur)&#125;$&#123;nthmark&#125;$&#123;idMark&#125;`);
        // svg元素会一直往上冒，由于 intersectionObser 对 svg 无效，所以需要获取完整的 xpath 来寻找最近的非 svg 元素
        if (idMark &amp;&amp; !hasSvgEle) &#123;
            path.push(&#39;&#39;);
            break;
        &#125;
        cur = cur.parentNode as HTMLElement;
    &#125;
    return `/$&#123;path.reverse().join(&#39;/&#39;)&#125;`;
&#125;
</code></pre>
<p>此部分完整代码可以参照<a target="_blank" rel="noopener" href="https://github.com/yuzai/dom-inspector-pro/blob/main/src/dom.ts">这个文件</a>。</p>
<p>至此，关于 xpath 的几个边界生成规则，便讲述完成了，接下来将会是由于代码的书写导致的 dom 结构不稳定从而导致的 xpath 不稳定的场景。</p>
<h2 id="dom-结构不稳定导致的-xpath-不稳"><a href="#dom-结构不稳定导致的-xpath-不稳" class="headerlink" title="dom 结构不稳定导致的 xpath 不稳"></a>dom 结构不稳定导致的 xpath 不稳</h2><p>除了在生成 xpath 时的边界场景，还有一个导致 xpath 不稳定的因素就在于我们日常代码中非常常见的一些组件的写法，此节便是对这些场景的分析。</p>
<p>同时为了解决这些问题，开发了一款 babel 插件对这些场景进行语法转换。目前代码并未开源，后文称之为 shadow-babel-plugin</p>
<h3 id="逻辑与-amp-amp-表达式"><a href="#逻辑与-amp-amp-表达式" class="headerlink" title="逻辑与 &amp;&amp; 表达式"></a>逻辑与 &amp;&amp; 表达式</h3><p>在 react 代码中，经常会写下如下代码：</p>
<pre><code class="jsx">function App() &#123;
    return (
        &lt;div&gt;
            &#123;a &amp;&amp; &lt;Comp1 /&gt;&#125;
            &#123;b &amp;&amp; &lt;Comp2 /&gt;&#125;
            &#123;c &amp;&amp; &lt;Comp3 /&gt;&#125;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>此时，当用户在 a,b 均为 false 时，对 comp3 录入了埋点，那么当实际上线后，a or b 发生了改变，此时 comp3 的 xpath 便有可能不会命中，此时便会导致 comp3 埋点的误判。</p>
<p>shadow-babel-plugin 针对该场景做了优化，上述代码会转换成以下代码：</p>
<pre><code class="jsx">function App() &#123;
    return (
        &lt;div&gt;
            &#123;a ? &lt;Comp1 /&gt; : &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt;&#125;
            &#123;b ? &lt;Comp2 /&gt; : &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt;&#125;
            &#123;c ? &lt;Comp3 /&gt; : &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt;&#125;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>当 a,b 为 false 时，此时会保留一个 display 为 none 的 空的 div 来维持原 dom 结构，从而一定程度上保证了 相邻元素的 xpath 的稳定性。</p>
<p>但是此时还是存在误判的场景，比如 a 为 false， b 为 true，那么此时 dom 结构是 <code>&lt;div /&gt;&lt;Comp2 /&gt;</code>，当 a 为 true，b 也为 true 时，此时 dom 结构是 <code>&lt;Comp1 /&gt;&lt;Comp2 /&gt;</code>，如果 comp1 的最外层不是 div，那么就会造成 comp2 的结构误判，故组件最好最外层以 div 包裹，才能最大程度的避免误判。</p>
<p>同时，也会对普通的 &amp;&amp; 表达式进行过滤，如果不涉及到 jsx，则不会转换。</p>
<p>与此同时，由于代码结构中多了一层 div，虽然绝大部分场景不会影响，但是 css 选择器 ，如 <code>nth-child</code> 等，包括父组件对第 x 的元素的特殊处理，还是会有影响。不过好在 babel 插件在开发时便引入，能够在开发阶段就发现问题。</p>
<h3 id="条件-表达式"><a href="#条件-表达式" class="headerlink" title="条件 ? 表达式"></a>条件 ? 表达式</h3><p>在 react 代码中，三元表达式的代码也非常常见，如下：</p>
<pre><code class="jsx">function App() &#123;
    return (
        &lt;div&gt;
            &#123;a ? &lt;Comp1 /&gt; : &lt;Comp2 /&gt;&#125;
            &#123;c ? &lt;Comp3 /&gt; : &lt;Comp4 /&gt;&#125;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>此时，当策划在埋点时，如果 a 为 false， c 为 false，那么此时页面内只有 comp2 和 comp4，当上线后，在某个状态下，a 为 true, c 为 true，那么此时页面内 只有 comp1 和 comp3，如果 comp1 和 comp2 结构类似，很容易造成 两者的误判。</p>
<p>shadow-babel-plugin 针对该场景做了优化，上述代码会转换成以下代码：</p>
<pre><code class="jsx">function App() &#123;
    return (
        &lt;div&gt;
            &#123; a ? &lt;Comp1 /&gt; : &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt; &#125;
            &#123; a ? &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt; : &lt;Comp2 /&gt; &#125;
            &#123; c ? &lt;Comp3 /&gt; : &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt; &#125;
            &#123; c ? &lt;div data-from-shadow=&quot;true&quot; style=&#123;&#123;"display": "none"&#125;&#125; /&gt; : &lt;Comp4 /&gt; &#125;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>此时，不论 a 是否为 false, 只会是 <code>&lt;Comp1 /&gt;&lt;div /&gt;</code> or <code>&lt;div /&gt;&lt;Comp2 /&gt;</code>，从 结构上，就 不会出现 comp1 和 comp2 的误判。comp3 和 comp4 同理。</p>
<p>但是此时还是存在误判的场景，比如 a 为 false， c 为 true，那么此时 dom 结构是 <code>&lt;div /&gt;&lt;Comp2 /&gt;&lt;comp3 /&gt;&lt;div /&gt;</code>(此时假设 comp2 comp3 最外层都是 div, 那么 comp3 的 xpath 为 div[3])，当 a 为 true，c 也为 true 时，此时 dom 结构是 <code>&lt;Comp1 /&gt;&lt;div /&gt;&lt;Comp3 /&gt;&lt;div /&gt;</code>，如果 comp1 的最外层不是 div，那么可能就会造成 comp3 的结构误判（假设 comp3 顶层是 div, 那么 xpath 便是 div[2]），故组件最好最外层以 div 包裹，才能最大程度的避免误判。</p>
<p>同时，该插件也会对普通 的 三元表达式进行过滤，如果不涉及到 jsx，则不会转换。</p>
<h3 id="动态-modal-场景"><a href="#动态-modal-场景" class="headerlink" title="动态 modal 场景"></a>动态 modal 场景</h3><p>在项目中最常见的便是动态 modal 的场景了，此场景下，一般会在 body 下新挂一个 div 作为 mask，同时会根据参数的不同对 div 进行保留，此时 modal 元素的 xpath 便会非常雷同。</p>
<p>比如页面中通过类似 <code>Modal.create</code> 方法或者静态 modal(其最终也会在 body 上挂载 div 实现)，创建了多个 modal，此时存在两个问题：</p>
<ol>
<li><p>modal 挂载在 body 下的 mask div 的顺序不同，顺序不同，就导致了同一个 modal 的 xpath 依赖弹窗打开的时机，这会造成非常大的误判</p>
</li>
<li><p>modal 挂载在 body 下的 div，结构非常类似，往往内部都是一张背景图 + 一些按钮，而策划运营需要的就是整个 modal 的曝光，圈选时便会指向最外侧的 div，此时误判会非常严重。</p>
</li>
</ol>
<p>针对这一场景，shadow-babel-plugin 增加了 id 作为唯一的判别标准。</p>
<p>完整的 xpath ，会从元素开始，一直收集到最顶层作为 xpath，而增加了 id 后，元素在碰到第一个 带有 id 的元素便会停止，忽略更顶层的结构。</p>
<p>在 modal 场景下，为每一个 modal 动态追加 id 属性，从而保障了弹窗的 xpath 稳定性。</p>
<p>在这一场景中，id 属性来自于代码执行的堆栈位置，故此 id 受代码修改的影响很大，尽可能的保证策划和运营在埋点后减少对代码的调整，或在代码调整后，及时查看对埋点的影响并及时重新选择埋点。</p>
<p>id 的生成是通过静态分析注入了运行时的代码，通过查找代码执行时堆栈所在的代码位置来作为唯一标记，生成代码如下：</p>
<pre><code class="js">(function() &#123;
    const a = new Error().stack.split(&#39;\\n&#39;);
    const max = a.length &lt;= 4 ? a.length : 4;
    let id = &#39;shadow-modal-id&#39;;
    for (let i = 1; i &lt; max; i++) &#123;
        const b = a[i].split(&#39;:&#39;);
        id += &#39;-&#39;;
        id += b[b.length - 1].replace(&#39;)&#39;, &#39;&#39;);
        id += &#39;-&#39;;
        id += b[b.length - 1];
    &#125;
    return id;
&#125;())
</code></pre>
<p>通过查找函数的执行堆栈位于代码中的位置，来作为唯一的 id 依据，通过这个方法，可以保证动态 modal 场景下，有唯一的 id 做支撑。但是这个方法也强依赖于代码，故需要在代码调整后，及时查看修改埋点。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>jsx 语法本身的灵活性，导致了有些场景下， dom 结构确实变化很大，很难进行区分。比如 动态组件场景，在 h5 中，最常见的便是 tab 场景，示例如下：</p>
<pre><code class="jsx">function App() &#123;
    // 动态组件1
    const Comp = useMemo(() =&gt; &#123;
        switch (tabIndex) &#123;
            case 1: return Comp1;
            case 2: return Comp2;
            case 3: return Comp3;
        &#125;
    &#125;, [tabIndex]);

    return (
        &lt;div&gt;
            &lt;Comp /&gt;
        &lt;/div&gt;
    );
&#125;
</code></pre>
<p>动态组件还有一些其他的写法，比如：</p>
<pre><code class="jsx">const map = &#123;
    1: Comp1,
    2: Comp2,
    3: Comp3,
&#125;

const Comp = map[type];
</code></pre>
<p>在这种动态组件写法下，dom 结构的重复性极高，很容易出现 comp1 ~ comp3 被重复命中的场景，同时，还会对其后面的兄弟节点产生影响，这一问题静态分析几乎没有意义，故需要使用者自行追加稳定性 id，比如：</p>
<pre><code class="jsx">// 为 comp1 追加 id 
function Comp1() &#123;
    return (
        &lt;div id=&quot;xxxx&quot;&gt;
        &lt;/div&gt;
    )
&#125;
</code></pre>
<p>而为了避免对兄弟节点造成干扰，需要保证 comp1 ~ comp3 最外层的 dom 原生 tag 保持一致，才可以避免对后面的兄弟节点带来 xpath 的干扰。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这一章节，分析了 逻辑与、三元表达式、动态 modal 以及动态组件的场景。</p>
<p>对于 逻辑与 以及 三元表达式的场景，开发了 babel 插件进行节点替换，能够避免很多 xpath 重复的场景。</p>
<p>但是节点的插入可能会会对原逻辑造成一定的影响，不过好在这些问题并不常遇到，即便遇到，也是开发时便能够发现，问题不算很大。</p>
<p>不过由于插入的节点是 div，为了避免对兄弟节点的影响，组件最外层最好通过 div 来包裹，以减少对兄弟组件的影响。</p>
<p>而对于 动态 modal 的场景，仅仅只能通过自动追加 id 的形式实现，但是 id 的生成强依赖于在代码中的位置，故需要开发者修改代码后及时查看，或自行增加 id 来解决。</p>
<p>至于动态组件的场景，静态分析实在没有好的解决方案，只能开发者自行添加 id 以区分。</p>
<h2 id="列表-xpath"><a href="#列表-xpath" class="headerlink" title="列表 xpath"></a>列表 xpath</h2><p>对于实际的使用过程中，还存在列表 xpath 如何生成的情况，关于列表元素的判定，在 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7184367763123601469">可视化埋点平台（三）：元素圈选器实现</a>，文章中有提及，而对于 xpath 的处理相对比较简单，只需要模糊 列表 tag 的顺序即可，简单来说，对于如下 dom 结构：</p>
<pre><code class="html">&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;div&gt;111&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;div&gt;111&lt;/div&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;div&gt;111&lt;/div&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>其中，ul 便是列表元素，将其之下的第一级子元素的位置进行模糊即可，生成的 xpath 如下：<code>html/body/div[1]/ul[1]/li[*]/div[1]</code>，关键点就在于 <code>li[*]</code>，通过指定 <code>*</code> ，从而模糊 li 的位置，这样，只需要不断迭代即可获取到所有的子元素。获取元素们的代码如下：</p>
<pre><code class="js">function getElesByXpath(xpath, max = 200) &#123;
    const doc = document;
    const result = doc.evaluate(xpath, doc);
    let item = result;
    const eles = [];
    let count = 0;
    while (item &amp;&amp; count &lt; max) &#123;
        item = result.iterateNext();
        if (item) &#123;
            eles.push(item);
        &#125;
        count++;
    &#125;
    return eles;
&#125;
</code></pre>
<p>实际使用时，可以通过 max 控制选择的元素数量。在做点击匹配时，可以直接比对 xpath 中的 <code>*</code> 与目标元素的 xpath 即可，并不需要全部获取到列表元素，此处的获取列表元素仅仅用于录入埋点后的反向验证。</p>
<h2 id="还有什么"><a href="#还有什么" class="headerlink" title="还有什么"></a>还有什么</h2><p>元素圈选浮层也会对 dom 结构造成影响，此处参考 vconsole 将浮层挂载在 html 的最后一个节点下，也就是不在 body 内，足以消除其对 dom 节点的影响。</p>
<p>在解决了 xpath 的稳定性后，本身平台还需要具备一些其他的能力，比如通信层的 iframe, 仅仅支持 iframe 在实际的场景中是不够的，因为 iframe 中往往存在登陆，以及 展示的 dom 结构同 app 内完全不同的情况。</p>
<p>故可视化埋点平台还需要支持直接在手机上打开的场景，这一部分通过 websocket 实现，将原本由 iframe 通信转发处理的信息，转而使用 websocket 进行转发，同时圈选器也支持移动端，即可实现该功能。</p>
<p>除此之外，目前可视化平台对于埋点自定义数据的携带，还存在功能上的缺陷，目前还没有想到非常好的完全不需要人工干预的方案，好在目前策划并没有非常纠结于这一点，毕竟大部分的自定义数据其实都可以通过从库中对数据处理来拿到，有想法的小伙伴可以评论区交流。</p>
<p>另，由于埋点脚本在获取初始埋点信息的时候，需要发送请求，这一步可以在构建的时候通过 webpack-plugin 将项目的埋点信息进行注入，来达到减少请求的优化。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，整个可视化埋点平台的建设及相关文章将会告一段落。</p>
<p>回头来看，整个可视化埋点系统链路还是比较长，功能点上也比较碎，涉及到 iframe 通信、ws 通信，元素圈选，webpack 插件，babel 插件的开发等等。</p>
<p>从产品角度来讲，个人认为目前在功能上已经覆盖了日常的场景，比如扫码手机圈选、列表圈选，数据离线等功能。大部分的过程都实现了无开发参与的目标。但是自定义埋点数据，目前还是一大痛点，并不能实现无人工下的自定义数据携带。</p>
<p>从技术角度来讲，整个链路涉及一些生僻 dom api，babel 替换节点，webpack 注入 js 等等，其中，元素的圈选逻辑已<a target="_blank" rel="noopener" href="https://github.com/yuzai/dom-inspector-pro">独立</a>，而整个项目的组件间通信，是通过自行定义的消息中心完成 iframe、ws 消息的收发与 react 组件的通信。整体来讲，技术上的细节还是挺多的。</p>
<p>最后，希望本文能够带给有相同需求的同学带来一点帮助吧。</p>
<p>ps：之前有评论区的同学提到，可视化埋点 由于 xpath 不稳定的一些缺陷，可以和低代码平台结合，由低代码平台生成自动生成 id，目测能够大幅提升 xpath 的稳定性，可能是良配，笔者待后续有机会可以和团队做的低代码平台合作看看。</p>

        </section>
        <hr class="post-divider">
        <div class="post-neighbors">
          
            <p class="post-neighbor-item">上一篇：<a href="/2023/01/03/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%8B%E7%82%B9%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%83%E7%B4%A0%E5%9C%88%E9%80%89%E5%99%A8%E5%AE%9E%E7%8E%B0/">可视化埋点（三）：元素圈选器实现</a></p>
          
          
            <p class="post-neighbor-item">下一篇：<a href="/2023/03/22/%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AC%BE%E8%B5%8F%E5%BF%83%E6%82%A6%E7%9B%AE%E7%9A%84%20React%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93/">设计一款赏心悦目的 React 状态管理库</a></p>
          
        </div>
        
          </div>
       </div>
       <div class="col-xs-12 col-sm-4 col-md-4 col-lg-4">
         <div style='overflow:auto' id='bfc'>
<div class = 'well' id = 'ab_ca'>


<h4>可视化埋点（四）：如何维持 Xpath 稳定性</h4>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xpath-%E7%AE%80%E4%BB%8B"><span class="toc-text">xpath 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90-xpath-%E7%9A%84%E8%BE%B9%E7%95%8C%E5%9C%BA%E6%99%AF"><span class="toc-text">生成 xpath 的边界场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#div-1-%E4%B8%8E-div"><span class="toc-text">div[1] 与 div</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#svg-%E5%85%83%E7%B4%A0"><span class="toc-text">svg 元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id-%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">id 的识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-%E7%BB%93%E6%9E%84%E4%B8%8D%E7%A8%B3%E5%AE%9A%E5%AF%BC%E8%87%B4%E7%9A%84-xpath-%E4%B8%8D%E7%A8%B3"><span class="toc-text">dom 结构不稳定导致的 xpath 不稳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E-amp-amp-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">逻辑与 &amp;&amp; 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">条件 ? 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-modal-%E5%9C%BA%E6%99%AF"><span class="toc-text">动态 modal 场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-text">动态组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-xpath"><span class="toc-text">列表 xpath</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-text">还有什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-text">最后</span></a></li></ol>
<h4>归档</h4>
<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/02/">二月 2026</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">五月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/04/">四月 2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li></ul>
<h4>最新文章</h4>
<ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2026/02/14/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%9C%80%E8%BF%91%E5%B8%AE%E4%BA%86%E6%88%91%E5%A4%A7%E5%BF%99%E7%9A%84css%E5%B1%9E%E6%80%A7/">分享一个最近帮我大忙的 CSS 属性：aspect-ratio</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/10/%E6%B7%B1%E5%85%A5%E8%81%8A%E8%81%8AQwen3%E7%9A%84%E6%B7%B7%E5%90%88%E6%8E%A8%E7%90%86%EF%BC%9A%E5%85%A8%E7%90%83%E5%94%AF%E4%B8%89%EF%BC%8C%E5%BC%80%E6%BA%90%E5%94%AF%E4%B8%80/">深入聊聊Qwen3的混合推理：全球唯三，开源唯一</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/08/%E6%B7%B1%E5%85%A5%E8%81%8A%E8%81%8AQwen3%EF%BC%9A%E6%88%91%E4%BB%AC%E5%A4%96%E8%A1%8C%E4%BA%BA%E9%99%A4%E4%BA%86%E9%AB%98%E5%91%BC%E6%B2%B8%E8%85%BE%E4%BA%86%EF%BC%8C%E8%BF%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88/">深入聊聊Qwen3：我们外行人除了高呼沸腾了，还应该知道什么?</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/29/%E8%BF%98%E6%98%AF%E8%81%8A%E8%81%8A%E5%90%A7%EF%BC%9A%22%E5%A4%A7%E9%BE%84%22%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%B1%E4%B8%9A%E7%9A%84%E4%B8%80%E5%B9%B4/">还是聊聊吧："大龄"程序员失业的一年</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/13/Cursor%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%BB%8E%E6%9D%A5%E9%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E6%AD%BB%E6%88%91%E6%B4%BB/">Cursor与程序员，从来都不是你死我活</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/%E5%9C%A8Cursor%E4%B8%AD%E7%94%A8%E4%B8%8A%E6%9C%80%E6%96%B0%E7%9A%84deepseek0324%E4%BA%86%EF%BC%81/">在Cursor中用上最新的deepseek0324了！</a></li></ul>

<h4>分类</h4>
<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E5%88%9B/">原创</a><span class="category-list-count">61</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E5%BE%97/">心得</a><span class="category-list-count">6</span></li></ul>


  <img id = 'my_picture' referrerpolicy="no-referrer">
  <h1 style='text-align:center;font-size:30px'>芋仔</h1>
  <ul id='aboutme'>
    <li><a  style = 'color:#000000' title = 'github' href="https://github.com/yuzai" role="button" target="_blank"><i class= 'icon-github'></i></a></li>
    <li><a  style = 'color:#62b900' title = 'wechat' href="/rs/wechat.jpg" role="button" target="_blank"><i class= 'icon-wechat'></i></a></li>
    <li><a  style = 'color:#2672ae' title = 'my store'href="https://www.zhihu.com/people/yu-zi-61-84" role="button" target="_blank"><i class= 'icon-zhihu-square'></i></a></li>
  </ul>

<h4>标签</h4>
<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/" rel="tag">DOM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/" rel="tag">ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome%E6%89%A9%E5%B1%95/" rel="tag">chrome扩展</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E4%B8%BB%E9%A2%98%E5%88%B6%E4%BD%9C/" rel="tag">hexo主题制作</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">前端面试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E6%80%9D/" rel="tag">反思</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" rel="tag">执行上下文</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/" rel="tag">柯里化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%96%91%E9%97%AE/" rel="tag">疑问</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%A8%E5%9F%9F/" rel="tag">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E5%BA%A6/" rel="tag">进度</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98/" rel="tag">问题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">2</span></li></ul>




</div>
</div>

      </div>
      </div>

      </div>
    </article>

</div>

<div style="position:fixed;right:1%;bottom:1%">
<button id="up" class="btn btn-success" style="color:green"><i class="icon-angle-up"></i></button>
</div>

<footer id="footer" class="myfoot">
  <div class="container-fluid">
    <div class="beian-wrap">
      <a class="beian-link" target="_blank" rel="noopener" href="http://beian.miit.gov.cn">浙ICP备2024109661号</a>
    </div>
  </div>
</footer>


    </div>
    <script src="/js/highlight.min.js"></script>
    
<script src="/js/index.js"></script>

    
<script src="/js/jquery-1.12.3.min.js"></script>

    
<script src="/js/bootstrap.min.js"></script>

    
    
<script src="/js/general.js"></script>

    
    
<script src="/js/post.js"></script>

    
    
<script src="/js/tag.js"></script>

    
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>
